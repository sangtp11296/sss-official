{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkimageediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Matcher } from 'ckeditor5/src/engine';\nimport { toMap } from 'ckeditor5/src/utils';\nimport LinkEditing from './linkediting';\n/**\n * The link image engine feature.\n *\n * It accepts the `linkHref=\"url\"` attribute in the model for the {@link module:image/image~Image `<imageBlock>`} element\n * which allows linking images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class LinkImageEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return ['ImageEditing', 'ImageUtils', LinkEditing];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'LinkImageEditing';\n  }\n\n  init() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n\n    if (editor.plugins.has('ImageBlockEditing')) {\n      schema.extend('imageBlock', {\n        allowAttributes: ['linkHref']\n      });\n    }\n\n    if (editor.plugins.has('ImageInlineEditing')) {\n      schema.extend('imageInline', {\n        allowAttributes: ['linkHref']\n      });\n    }\n\n    editor.conversion.for('upcast').add(upcastLink(editor));\n    editor.conversion.for('downcast').add(downcastImageLink(editor)); // Definitions for decorators are provided by the `link` command and the `LinkEditing` plugin.\n\n    this._enableAutomaticDecorators();\n\n    this._enableManualDecorators();\n  }\n  /**\n   * Processes {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators} definitions and\n   * attaches proper converters that will work when linking an image.`\n   *\n   * @private\n   */\n\n\n  _enableAutomaticDecorators() {\n    const editor = this.editor;\n    const command = editor.commands.get('link');\n    const automaticDecorators = command.automaticDecorators;\n\n    if (automaticDecorators.length) {\n      editor.conversion.for('downcast').add(automaticDecorators.getDispatcherForLinkedImage());\n    }\n  }\n  /**\n   * Processes transformed {@link module:link/utils~ManualDecorator} instances and attaches proper converters\n   * that will work when linking an image.\n   *\n   * @private\n   */\n\n\n  _enableManualDecorators() {\n    const editor = this.editor;\n    const command = editor.commands.get('link');\n\n    for (const decorator of command.manualDecorators) {\n      if (editor.plugins.has('ImageBlockEditing')) {\n        editor.model.schema.extend('imageBlock', {\n          allowAttributes: decorator.id\n        });\n      }\n\n      if (editor.plugins.has('ImageInlineEditing')) {\n        editor.model.schema.extend('imageInline', {\n          allowAttributes: decorator.id\n        });\n      }\n\n      editor.conversion.for('downcast').add(downcastImageLinkManualDecorator(decorator));\n      editor.conversion.for('upcast').add(upcastImageLinkManualDecorator(editor, decorator));\n    }\n  }\n\n} // Returns a converter for linked block images that consumes the \"href\" attribute\n// if a link contains an image.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor The editor instance.\n// @returns {Function}\n\nfunction upcastLink(editor) {\n  const isImageInlinePluginLoaded = editor.plugins.has('ImageInlineEditing');\n  const imageUtils = editor.plugins.get('ImageUtils');\n  return dispatcher => {\n    dispatcher.on('element:a', (evt, data, conversionApi) => {\n      const viewLink = data.viewItem;\n      const imageInLink = imageUtils.findViewImgElement(viewLink);\n\n      if (!imageInLink) {\n        return;\n      }\n\n      const blockImageView = imageInLink.findAncestor(element => imageUtils.isBlockImageView(element)); // There are four possible cases to consider here\n      //\n      // 1. A \"root > ... > figure.image > a > img\" structure.\n      // 2. A \"root > ... > figure.image > a > picture > img\" structure.\n      // 3. A \"root > ... > block > a > img\" structure.\n      // 4. A \"root > ... > block > a > picture > img\" structure.\n      //\n      // but the last 2 cases should only be considered by this converter when the inline image plugin\n      // is NOT loaded in the editor (because otherwise, that would be a plain, linked inline image).\n\n      if (isImageInlinePluginLoaded && !blockImageView) {\n        return;\n      } // There's an image inside an <a> element - we consume it so it won't be picked up by the Link plugin.\n\n\n      const consumableAttributes = {\n        attributes: ['href']\n      }; // Consume the `href` attribute so the default one will not convert it to $text attribute.\n\n      if (!conversionApi.consumable.consume(viewLink, consumableAttributes)) {\n        // Might be consumed by something else - i.e. other converter with priority=highest - a standard check.\n        return;\n      }\n\n      const linkHref = viewLink.getAttribute('href'); // Missing the 'href' attribute.\n\n      if (!linkHref) {\n        return;\n      } // A full definition of the image feature.\n      // figure > a > img: parent of the view link element is an image element (figure).\n\n\n      let modelElement = data.modelCursor.parent;\n\n      if (!modelElement.is('element', 'imageBlock')) {\n        // a > img: parent of the view link is not the image (figure) element. We need to convert it manually.\n        const conversionResult = conversionApi.convertItem(imageInLink, data.modelCursor); // Set image range as conversion result.\n\n        data.modelRange = conversionResult.modelRange; // Continue conversion where image conversion ends.\n\n        data.modelCursor = conversionResult.modelCursor;\n        modelElement = data.modelCursor.nodeBefore;\n      }\n\n      if (modelElement && modelElement.is('element', 'imageBlock')) {\n        // Set the linkHref attribute from link element on model image element.\n        conversionApi.writer.setAttribute('linkHref', linkHref, modelElement);\n      }\n    }, {\n      priority: 'high'\n    }); // Using the same priority that `upcastImageLinkManualDecorator()` converter guarantees\n    // that manual decorators will decorate the proper element.\n  };\n} // Creates a converter that adds `<a>` to linked block image view elements.\n//\n// @private\n\n\nfunction downcastImageLink(editor) {\n  const imageUtils = editor.plugins.get('ImageUtils');\n  return dispatcher => {\n    dispatcher.on('attribute:linkHref:imageBlock', (evt, data, conversionApi) => {\n      if (!conversionApi.consumable.consume(data.item, evt.name)) {\n        return;\n      } // The image will be already converted - so it will be present in the view.\n\n\n      const viewFigure = conversionApi.mapper.toViewElement(data.item);\n      const writer = conversionApi.writer; // But we need to check whether the link element exists.\n\n      const linkInImage = Array.from(viewFigure.getChildren()).find(child => child.name === 'a');\n      const viewImage = imageUtils.findViewImgElement(viewFigure); // <picture>...<img/></picture> or <img/>\n\n      const viewImgOrPicture = viewImage.parent.is('element', 'picture') ? viewImage.parent : viewImage; // If so, update the attribute if it's defined or remove the entire link if the attribute is empty.\n\n      if (linkInImage) {\n        if (data.attributeNewValue) {\n          writer.setAttribute('href', data.attributeNewValue, linkInImage);\n        } else {\n          writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(viewFigure, 0));\n          writer.remove(linkInImage);\n        }\n      } else {\n        // But if it does not exist. Let's wrap already converted image by newly created link element.\n        // 1. Create an empty link element.\n        const linkElement = writer.createContainerElement('a', {\n          href: data.attributeNewValue\n        }); // 2. Insert link inside the associated image.\n\n        writer.insert(writer.createPositionAt(viewFigure, 0), linkElement); // 3. Move the image to the link.\n\n        writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(linkElement, 0));\n      }\n    }, {\n      priority: 'high'\n    });\n  };\n} // Returns a converter that decorates the `<a>` element when the image is the link label.\n//\n// @private\n// @returns {Function}\n\n\nfunction downcastImageLinkManualDecorator(decorator) {\n  return dispatcher => {\n    dispatcher.on(`attribute:${decorator.id}:imageBlock`, (evt, data, conversionApi) => {\n      const viewFigure = conversionApi.mapper.toViewElement(data.item);\n      const linkInImage = Array.from(viewFigure.getChildren()).find(child => child.name === 'a'); // The <a> element was removed by the time this converter is executed.\n      // It may happen when the base `linkHref` and decorator attributes are removed\n      // at the same time (see #8401).\n\n      if (!linkInImage) {\n        return;\n      }\n\n      for (const [key, val] of toMap(decorator.attributes)) {\n        conversionApi.writer.setAttribute(key, val, linkInImage);\n      }\n\n      if (decorator.classes) {\n        conversionApi.writer.addClass(decorator.classes, linkInImage);\n      }\n\n      for (const key in decorator.styles) {\n        conversionApi.writer.setStyle(key, decorator.styles[key], linkInImage);\n      }\n    });\n  };\n} // Returns a converter that checks whether manual decorators should be applied to the link.\n//\n// @private\n// @returns {Function}\n\n\nfunction upcastImageLinkManualDecorator(editor, decorator) {\n  const imageUtils = editor.plugins.get('ImageUtils');\n  return dispatcher => {\n    dispatcher.on('element:a', (evt, data, conversionApi) => {\n      const viewLink = data.viewItem;\n      const imageInLink = imageUtils.findViewImgElement(viewLink); // We need to check whether an image is inside a link because the converter handles\n      // only manual decorators for linked images. See #7975.\n\n      if (!imageInLink) {\n        return;\n      }\n\n      const matcher = new Matcher(decorator._createPattern());\n      const result = matcher.match(viewLink); // The link element does not have required attributes or/and proper values.\n\n      if (!result) {\n        return;\n      } // Check whether we can consume those attributes.\n\n\n      if (!conversionApi.consumable.consume(viewLink, result.match)) {\n        return;\n      } // At this stage we can assume that we have the `<imageBlock>` element.\n      // `nodeBefore` comes after conversion: `<a><img></a>`.\n      // `parent` comes with full image definition: `<figure><a><img></a></figure>.\n      // See the body of the `upcastLink()` function.\n\n\n      const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;\n      conversionApi.writer.setAttribute(decorator.id, true, modelElement);\n    }, {\n      priority: 'high'\n    }); // Using the same priority that `upcastLink()` converter guarantees that the linked image was properly converted.\n  };\n}","map":{"version":3,"sources":["C:/Users/sangt/OneDrive/Sang Shares Something/sss-official/client/node_modules/@ckeditor/ckeditor5-link/src/linkimageediting.js"],"names":["Plugin","Matcher","toMap","LinkEditing","LinkImageEditing","requires","pluginName","init","editor","schema","model","plugins","has","extend","allowAttributes","conversion","for","add","upcastLink","downcastImageLink","_enableAutomaticDecorators","_enableManualDecorators","command","commands","get","automaticDecorators","length","getDispatcherForLinkedImage","decorator","manualDecorators","id","downcastImageLinkManualDecorator","upcastImageLinkManualDecorator","isImageInlinePluginLoaded","imageUtils","dispatcher","on","evt","data","conversionApi","viewLink","viewItem","imageInLink","findViewImgElement","blockImageView","findAncestor","element","isBlockImageView","consumableAttributes","attributes","consumable","consume","linkHref","getAttribute","modelElement","modelCursor","parent","is","conversionResult","convertItem","modelRange","nodeBefore","writer","setAttribute","priority","item","name","viewFigure","mapper","toViewElement","linkInImage","Array","from","getChildren","find","child","viewImage","viewImgOrPicture","attributeNewValue","move","createRangeOn","createPositionAt","remove","linkElement","createContainerElement","href","insert","key","val","classes","addClass","styles","setStyle","matcher","_createPattern","result","match"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkimageediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Matcher } from 'ckeditor5/src/engine';\nimport { toMap } from 'ckeditor5/src/utils';\n\nimport LinkEditing from './linkediting';\n\n/**\n * The link image engine feature.\n *\n * It accepts the `linkHref=\"url\"` attribute in the model for the {@link module:image/image~Image `<imageBlock>`} element\n * which allows linking images.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class LinkImageEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ 'ImageEditing', 'ImageUtils', LinkEditing ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'LinkImageEditing';\n\t}\n\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\n\t\tif ( editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\t\tschema.extend( 'imageBlock', { allowAttributes: [ 'linkHref' ] } );\n\t\t}\n\n\t\tif ( editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\t\tschema.extend( 'imageInline', { allowAttributes: [ 'linkHref' ] } );\n\t\t}\n\n\t\teditor.conversion.for( 'upcast' ).add( upcastLink( editor ) );\n\t\teditor.conversion.for( 'downcast' ).add( downcastImageLink( editor ) );\n\n\t\t// Definitions for decorators are provided by the `link` command and the `LinkEditing` plugin.\n\t\tthis._enableAutomaticDecorators();\n\t\tthis._enableManualDecorators();\n\t}\n\n\t/**\n\t * Processes {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators} definitions and\n\t * attaches proper converters that will work when linking an image.`\n\t *\n\t * @private\n\t */\n\t_enableAutomaticDecorators() {\n\t\tconst editor = this.editor;\n\t\tconst command = editor.commands.get( 'link' );\n\t\tconst automaticDecorators = command.automaticDecorators;\n\n\t\tif ( automaticDecorators.length ) {\n\t\t\teditor.conversion.for( 'downcast' ).add( automaticDecorators.getDispatcherForLinkedImage() );\n\t\t}\n\t}\n\n\t/**\n\t * Processes transformed {@link module:link/utils~ManualDecorator} instances and attaches proper converters\n\t * that will work when linking an image.\n\t *\n\t * @private\n\t */\n\t_enableManualDecorators() {\n\t\tconst editor = this.editor;\n\t\tconst command = editor.commands.get( 'link' );\n\n\t\tfor ( const decorator of command.manualDecorators ) {\n\t\t\tif ( editor.plugins.has( 'ImageBlockEditing' ) ) {\n\t\t\t\teditor.model.schema.extend( 'imageBlock', { allowAttributes: decorator.id } );\n\t\t\t}\n\n\t\t\tif ( editor.plugins.has( 'ImageInlineEditing' ) ) {\n\t\t\t\teditor.model.schema.extend( 'imageInline', { allowAttributes: decorator.id } );\n\t\t\t}\n\n\t\t\teditor.conversion.for( 'downcast' ).add( downcastImageLinkManualDecorator( decorator ) );\n\t\t\teditor.conversion.for( 'upcast' ).add( upcastImageLinkManualDecorator( editor, decorator ) );\n\t\t}\n\t}\n}\n\n// Returns a converter for linked block images that consumes the \"href\" attribute\n// if a link contains an image.\n//\n// @private\n// @param {module:core/editor/editor~Editor} editor The editor instance.\n// @returns {Function}\nfunction upcastLink( editor ) {\n\tconst isImageInlinePluginLoaded = editor.plugins.has( 'ImageInlineEditing' );\n\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n\t\t\tconst viewLink = data.viewItem;\n\t\t\tconst imageInLink = imageUtils.findViewImgElement( viewLink );\n\n\t\t\tif ( !imageInLink ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst blockImageView = imageInLink.findAncestor( element => imageUtils.isBlockImageView( element ) );\n\n\t\t\t// There are four possible cases to consider here\n\t\t\t//\n\t\t\t// 1. A \"root > ... > figure.image > a > img\" structure.\n\t\t\t// 2. A \"root > ... > figure.image > a > picture > img\" structure.\n\t\t\t// 3. A \"root > ... > block > a > img\" structure.\n\t\t\t// 4. A \"root > ... > block > a > picture > img\" structure.\n\t\t\t//\n\t\t\t// but the last 2 cases should only be considered by this converter when the inline image plugin\n\t\t\t// is NOT loaded in the editor (because otherwise, that would be a plain, linked inline image).\n\t\t\tif ( isImageInlinePluginLoaded && !blockImageView ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// There's an image inside an <a> element - we consume it so it won't be picked up by the Link plugin.\n\t\t\tconst consumableAttributes = { attributes: [ 'href' ] };\n\n\t\t\t// Consume the `href` attribute so the default one will not convert it to $text attribute.\n\t\t\tif ( !conversionApi.consumable.consume( viewLink, consumableAttributes ) ) {\n\t\t\t\t// Might be consumed by something else - i.e. other converter with priority=highest - a standard check.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst linkHref = viewLink.getAttribute( 'href' );\n\n\t\t\t// Missing the 'href' attribute.\n\t\t\tif ( !linkHref ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// A full definition of the image feature.\n\t\t\t// figure > a > img: parent of the view link element is an image element (figure).\n\t\t\tlet modelElement = data.modelCursor.parent;\n\n\t\t\tif ( !modelElement.is( 'element', 'imageBlock' ) ) {\n\t\t\t\t// a > img: parent of the view link is not the image (figure) element. We need to convert it manually.\n\t\t\t\tconst conversionResult = conversionApi.convertItem( imageInLink, data.modelCursor );\n\n\t\t\t\t// Set image range as conversion result.\n\t\t\t\tdata.modelRange = conversionResult.modelRange;\n\n\t\t\t\t// Continue conversion where image conversion ends.\n\t\t\t\tdata.modelCursor = conversionResult.modelCursor;\n\n\t\t\t\tmodelElement = data.modelCursor.nodeBefore;\n\t\t\t}\n\n\t\t\tif ( modelElement && modelElement.is( 'element', 'imageBlock' ) ) {\n\t\t\t\t// Set the linkHref attribute from link element on model image element.\n\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', linkHref, modelElement );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t\t// Using the same priority that `upcastImageLinkManualDecorator()` converter guarantees\n\t\t// that manual decorators will decorate the proper element.\n\t};\n}\n\n// Creates a converter that adds `<a>` to linked block image view elements.\n//\n// @private\nfunction downcastImageLink( editor ) {\n\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'attribute:linkHref:imageBlock', ( evt, data, conversionApi ) => {\n\t\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The image will be already converted - so it will be present in the view.\n\t\t\tconst viewFigure = conversionApi.mapper.toViewElement( data.item );\n\t\t\tconst writer = conversionApi.writer;\n\n\t\t\t// But we need to check whether the link element exists.\n\t\t\tconst linkInImage = Array.from( viewFigure.getChildren() ).find( child => child.name === 'a' );\n\t\t\tconst viewImage = imageUtils.findViewImgElement( viewFigure );\n\t\t\t// <picture>...<img/></picture> or <img/>\n\t\t\tconst viewImgOrPicture = viewImage.parent.is( 'element', 'picture' ) ? viewImage.parent : viewImage;\n\n\t\t\t// If so, update the attribute if it's defined or remove the entire link if the attribute is empty.\n\t\t\tif ( linkInImage ) {\n\t\t\t\tif ( data.attributeNewValue ) {\n\t\t\t\t\twriter.setAttribute( 'href', data.attributeNewValue, linkInImage );\n\t\t\t\t} else {\n\t\t\t\t\twriter.move( writer.createRangeOn( viewImgOrPicture ), writer.createPositionAt( viewFigure, 0 ) );\n\t\t\t\t\twriter.remove( linkInImage );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// But if it does not exist. Let's wrap already converted image by newly created link element.\n\t\t\t\t// 1. Create an empty link element.\n\t\t\t\tconst linkElement = writer.createContainerElement( 'a', { href: data.attributeNewValue } );\n\n\t\t\t\t// 2. Insert link inside the associated image.\n\t\t\t\twriter.insert( writer.createPositionAt( viewFigure, 0 ), linkElement );\n\n\t\t\t\t// 3. Move the image to the link.\n\t\t\t\twriter.move( writer.createRangeOn( viewImgOrPicture ), writer.createPositionAt( linkElement, 0 ) );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t};\n}\n\n// Returns a converter that decorates the `<a>` element when the image is the link label.\n//\n// @private\n// @returns {Function}\nfunction downcastImageLinkManualDecorator( decorator ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `attribute:${ decorator.id }:imageBlock`, ( evt, data, conversionApi ) => {\n\t\t\tconst viewFigure = conversionApi.mapper.toViewElement( data.item );\n\t\t\tconst linkInImage = Array.from( viewFigure.getChildren() ).find( child => child.name === 'a' );\n\n\t\t\t// The <a> element was removed by the time this converter is executed.\n\t\t\t// It may happen when the base `linkHref` and decorator attributes are removed\n\t\t\t// at the same time (see #8401).\n\t\t\tif ( !linkInImage ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( const [ key, val ] of toMap( decorator.attributes ) ) {\n\t\t\t\tconversionApi.writer.setAttribute( key, val, linkInImage );\n\t\t\t}\n\n\t\t\tif ( decorator.classes ) {\n\t\t\t\tconversionApi.writer.addClass( decorator.classes, linkInImage );\n\t\t\t}\n\n\t\t\tfor ( const key in decorator.styles ) {\n\t\t\t\tconversionApi.writer.setStyle( key, decorator.styles[ key ], linkInImage );\n\t\t\t}\n\t\t} );\n\t};\n}\n\n// Returns a converter that checks whether manual decorators should be applied to the link.\n//\n// @private\n// @returns {Function}\nfunction upcastImageLinkManualDecorator( editor, decorator ) {\n\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n\t\t\tconst viewLink = data.viewItem;\n\t\t\tconst imageInLink = imageUtils.findViewImgElement( viewLink );\n\n\t\t\t// We need to check whether an image is inside a link because the converter handles\n\t\t\t// only manual decorators for linked images. See #7975.\n\t\t\tif ( !imageInLink ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst matcher = new Matcher( decorator._createPattern() );\n\t\t\tconst result = matcher.match( viewLink );\n\n\t\t\t// The link element does not have required attributes or/and proper values.\n\t\t\tif ( !result ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check whether we can consume those attributes.\n\t\t\tif ( !conversionApi.consumable.consume( viewLink, result.match ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// At this stage we can assume that we have the `<imageBlock>` element.\n\t\t\t// `nodeBefore` comes after conversion: `<a><img></a>`.\n\t\t\t// `parent` comes with full image definition: `<figure><a><img></a></figure>.\n\t\t\t// See the body of the `upcastLink()` function.\n\t\t\tconst modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;\n\n\t\t\tconversionApi.writer.setAttribute( decorator.id, true, modelElement );\n\t\t}, { priority: 'high' } );\n\t\t// Using the same priority that `upcastLink()` converter guarantees that the linked image was properly converted.\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}