{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { MouseObserver } from 'ckeditor5/src/engine';\nimport { Input, TwoStepCaretMovement, inlineHighlight, findAttributeRange } from 'ckeditor5/src/typing';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { keyCodes } from 'ckeditor5/src/utils';\nimport LinkCommand from './linkcommand';\nimport UnlinkCommand from './unlinkcommand';\nimport ManualDecorator from './utils/manualdecorator';\nimport { createLinkElement, ensureSafeUrl, getLocalizedDecorators, normalizeDecorators } from './utils';\nimport '../theme/link.css';\nconst HIGHLIGHT_CLASS = 'ck-link_selected';\nconst DECORATOR_AUTOMATIC = 'automatic';\nconst DECORATOR_MANUAL = 'manual';\nconst EXTERNAL_LINKS_REGEXP = /^(https?:)?\\/\\//;\n/**\n * The link engine feature.\n *\n * It introduces the `linkHref=\"url\"` attribute in the model which renders to the view as a `<a href=\"url\">` element\n * as well as `'link'` and `'unlink'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class LinkEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'LinkEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    // Clipboard is required for handling cut and paste events while typing over the link.\n    return [TwoStepCaretMovement, Input, ClipboardPipeline];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    editor.config.define('link', {\n      addTargetToExternalLinks: false\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor; // Allow link attribute on all inline nodes.\n\n    editor.model.schema.extend('$text', {\n      allowAttributes: 'linkHref'\n    });\n    editor.conversion.for('dataDowncast').attributeToElement({\n      model: 'linkHref',\n      view: createLinkElement\n    });\n    editor.conversion.for('editingDowncast').attributeToElement({\n      model: 'linkHref',\n      view: (href, conversionApi) => {\n        return createLinkElement(ensureSafeUrl(href), conversionApi);\n      }\n    });\n    editor.conversion.for('upcast').elementToAttribute({\n      view: {\n        name: 'a',\n        attributes: {\n          href: true\n        }\n      },\n      model: {\n        key: 'linkHref',\n        value: viewElement => viewElement.getAttribute('href')\n      }\n    }); // Create linking commands.\n\n    editor.commands.add('link', new LinkCommand(editor));\n    editor.commands.add('unlink', new UnlinkCommand(editor));\n    const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get('link.decorators')));\n\n    this._enableAutomaticDecorators(linkDecorators.filter(item => item.mode === DECORATOR_AUTOMATIC));\n\n    this._enableManualDecorators(linkDecorators.filter(item => item.mode === DECORATOR_MANUAL)); // Enable two-step caret movement for `linkHref` attribute.\n\n\n    const twoStepCaretMovementPlugin = editor.plugins.get(TwoStepCaretMovement);\n    twoStepCaretMovementPlugin.registerAttribute('linkHref'); // Setup highlight over selected link.\n\n    inlineHighlight(editor, 'linkHref', 'a', HIGHLIGHT_CLASS); // Change the attributes of the selection in certain situations after the link was inserted into the document.\n\n    this._enableInsertContentSelectionAttributesFixer(); // Handle a click at the beginning/end of a link element.\n\n\n    this._enableClickingAfterLink(); // Handle typing over the link.\n\n\n    this._enableTypingOverLink(); // Handle removing the content after the link element.\n\n\n    this._handleDeleteContentAfterLink();\n  }\n  /**\n   * Processes an array of configured {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}\n   * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}\n   * for each one of them. Downcast dispatchers are obtained using the\n   * {@link module:link/utils~AutomaticDecorators#getDispatcher} method.\n   *\n   * **Note**: This method also activates the automatic external link decorator if enabled with\n   * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.\n   *\n   * @private\n   * @param {Array.<module:link/link~LinkDecoratorAutomaticDefinition>} automaticDecoratorDefinitions\n   */\n\n\n  _enableAutomaticDecorators(automaticDecoratorDefinitions) {\n    const editor = this.editor; // Store automatic decorators in the command instance as we do the same with manual decorators.\n    // Thanks to that, `LinkImageEditing` plugin can re-use the same definitions.\n\n    const command = editor.commands.get('link');\n    const automaticDecorators = command.automaticDecorators; // Adds a default decorator for external links.\n\n    if (editor.config.get('link.addTargetToExternalLinks')) {\n      automaticDecorators.add({\n        id: 'linkIsExternal',\n        mode: DECORATOR_AUTOMATIC,\n        callback: url => EXTERNAL_LINKS_REGEXP.test(url),\n        attributes: {\n          target: '_blank',\n          rel: 'noopener noreferrer'\n        }\n      });\n    }\n\n    automaticDecorators.add(automaticDecoratorDefinitions);\n\n    if (automaticDecorators.length) {\n      editor.conversion.for('downcast').add(automaticDecorators.getDispatcher());\n    }\n  }\n  /**\n   * Processes an array of configured {@link module:link/link~LinkDecoratorManualDefinition manual decorators},\n   * transforms them into {@link module:link/utils~ManualDecorator} instances and stores them in the\n   * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).\n   *\n   * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}\n   * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}\n   * with adequate model attributes.\n   *\n   * @private\n   * @param {Array.<module:link/link~LinkDecoratorManualDefinition>} manualDecoratorDefinitions\n   */\n\n\n  _enableManualDecorators(manualDecoratorDefinitions) {\n    if (!manualDecoratorDefinitions.length) {\n      return;\n    }\n\n    const editor = this.editor;\n    const command = editor.commands.get('link');\n    const manualDecorators = command.manualDecorators;\n    manualDecoratorDefinitions.forEach(decorator => {\n      editor.model.schema.extend('$text', {\n        allowAttributes: decorator.id\n      }); // Keeps reference to manual decorator to decode its name to attributes during downcast.\n\n      decorator = new ManualDecorator(decorator);\n      manualDecorators.add(decorator);\n      editor.conversion.for('downcast').attributeToElement({\n        model: decorator.id,\n        view: (manualDecoratorName, {\n          writer\n        }) => {\n          if (manualDecoratorName) {\n            const element = writer.createAttributeElement('a', decorator.attributes, {\n              priority: 5\n            });\n\n            if (decorator.classes) {\n              writer.addClass(decorator.classes, element);\n            }\n\n            for (const key in decorator.styles) {\n              writer.setStyle(key, decorator.styles[key], element);\n            }\n\n            writer.setCustomProperty('link', true, element);\n            return element;\n          }\n        }\n      });\n      editor.conversion.for('upcast').elementToAttribute({\n        view: {\n          name: 'a',\n          ...decorator._createPattern()\n        },\n        model: {\n          key: decorator.id\n        }\n      });\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model\n   * selection attributes if the selection is at the end of a link after inserting the content.\n   *\n   * The purpose of this action is to improve the overall UX because the user is no longer \"trapped\" by the\n   * `linkHref` attribute of the selection and they can type a \"clean\" (`linkHref`–less) text right away.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/6053.\n   *\n   * @private\n   */\n\n\n  _enableInsertContentSelectionAttributesFixer() {\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    this.listenTo(model, 'insertContent', () => {\n      const nodeBefore = selection.anchor.nodeBefore;\n      const nodeAfter = selection.anchor.nodeAfter; // NOTE: ↰ and ↱ represent the gravity of the selection.\n      // The only truly valid case is:\n      //\n      //\t\t                                 ↰\n      //\t\t...<$text linkHref=\"foo\">INSERTED[]</$text>\n      //\n      // If the selection is not \"trapped\" by the `linkHref` attribute after inserting, there's nothing\n      // to fix there.\n\n      if (!selection.hasAttribute('linkHref')) {\n        return;\n      } // Filter out the following case where a link with the same href (e.g. <a href=\"foo\">INSERTED</a>) is inserted\n      // in the middle of an existing link:\n      //\n      // Before insertion:\n      //\t\t                       ↰\n      //\t\t<$text linkHref=\"foo\">l[]ink</$text>\n      //\n      // Expected after insertion:\n      //\t\t                               ↰\n      //\t\t<$text linkHref=\"foo\">lINSERTED[]ink</$text>\n      //\n\n\n      if (!nodeBefore) {\n        return;\n      } // Filter out the following case where the selection has the \"linkHref\" attribute because the\n      // gravity is overridden and some text with another attribute (e.g. <b>INSERTED</b>) is inserted:\n      //\n      // Before insertion:\n      //\n      //\t\t                       ↱\n      //\t\t<$text linkHref=\"foo\">[]link</$text>\n      //\n      // Expected after insertion:\n      //\n      //\t\t                                                          ↱\n      //\t\t<$text bold=\"true\">INSERTED</$text><$text linkHref=\"foo\">[]link</$text>\n      //\n\n\n      if (!nodeBefore.hasAttribute('linkHref')) {\n        return;\n      } // Filter out the following case where a link is a inserted in the middle (or before) another link\n      // (different URLs, so they will not merge). In this (let's say weird) case, we can leave the selection\n      // attributes as they are because the user will end up writing in one link or another anyway.\n      //\n      // Before insertion:\n      //\n      //\t\t                       ↰\n      //\t\t<$text linkHref=\"foo\">l[]ink</$text>\n      //\n      // Expected after insertion:\n      //\n      //\t\t                                                             ↰\n      //\t\t<$text linkHref=\"foo\">l</$text><$text linkHref=\"bar\">INSERTED[]</$text><$text linkHref=\"foo\">ink</$text>\n      //\n\n\n      if (nodeAfter && nodeAfter.hasAttribute('linkHref')) {\n        return;\n      }\n\n      model.change(writer => {\n        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n      });\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and\n   * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node\n   * if clicked at the beginning/ending of the link.\n   *\n   * The purpose of this action is to allow typing around the link node directly after a click.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/1016.\n   *\n   * @private\n   */\n\n\n  _enableClickingAfterLink() {\n    const editor = this.editor;\n    const model = editor.model;\n    editor.editing.view.addObserver(MouseObserver);\n    let clicked = false; // Detect the click.\n\n    this.listenTo(editor.editing.view.document, 'mousedown', () => {\n      clicked = true;\n    }); // When the selection has changed...\n\n    this.listenTo(editor.editing.view.document, 'selectionChange', () => {\n      if (!clicked) {\n        return;\n      } // ...and it was caused by the click...\n\n\n      clicked = false;\n      const selection = model.document.selection; // ...and no text is selected...\n\n      if (!selection.isCollapsed) {\n        return;\n      } // ...and clicked text is the link...\n\n\n      if (!selection.hasAttribute('linkHref')) {\n        return;\n      }\n\n      const position = selection.getFirstPosition();\n      const linkRange = findAttributeRange(position, 'linkHref', selection.getAttribute('linkHref'), model); // ...check whether clicked start/end boundary of the link.\n      // If so, remove the `linkHref` attribute.\n\n      if (position.isTouching(linkRange.start) || position.isTouching(linkRange.end)) {\n        model.change(writer => {\n          removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n        });\n      }\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}\n   * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.\n   *\n   * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/4762.\n   *\n   * @private\n   */\n\n\n  _enableTypingOverLink() {\n    const editor = this.editor;\n    const view = editor.editing.view; // Selection attributes when started typing over the link.\n\n    let selectionAttributes; // Whether pressed `Backspace` or `Delete`. If so, attributes should not be preserved.\n\n    let deletedContent; // Detect pressing `Backspace` / `Delete`.\n\n    this.listenTo(view.document, 'delete', () => {\n      deletedContent = true;\n    }, {\n      priority: 'high'\n    }); // Listening to `model#deleteContent` allows detecting whether selected content was a link.\n    // If so, before removing the element, we will copy its attributes.\n\n    this.listenTo(editor.model, 'deleteContent', () => {\n      const selection = editor.model.document.selection; // Copy attributes only if anything is selected.\n\n      if (selection.isCollapsed) {\n        return;\n      } // When the content was deleted, do not preserve attributes.\n\n\n      if (deletedContent) {\n        deletedContent = false;\n        return;\n      } // Enabled only when typing.\n\n\n      if (!isTyping(editor)) {\n        return;\n      }\n\n      if (shouldCopyAttributes(editor.model)) {\n        selectionAttributes = selection.getAttributes();\n      }\n    }, {\n      priority: 'high'\n    }); // Listening to `model#insertContent` allows detecting the content insertion.\n    // We want to apply attributes that were removed while typing over the link.\n\n    this.listenTo(editor.model, 'insertContent', (evt, [element]) => {\n      deletedContent = false; // Enabled only when typing.\n\n      if (!isTyping(editor)) {\n        return;\n      }\n\n      if (!selectionAttributes) {\n        return;\n      }\n\n      editor.model.change(writer => {\n        for (const [attribute, value] of selectionAttributes) {\n          writer.setAttribute(attribute, value, element);\n        }\n      });\n      selectionAttributes = null;\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether\n   * removing a content right after the \"linkHref\" attribute.\n   *\n   * If so, the selection should not preserve the `linkHref` attribute. However, if\n   * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and\n   * the selection has the \"linkHref\" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.\n   *\n   * The purpose of this action is to allow removing the link text and keep the selection outside the link.\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/7521.\n   *\n   * @private\n   */\n\n\n  _handleDeleteContentAfterLink() {\n    const editor = this.editor;\n    const model = editor.model;\n    const selection = model.document.selection;\n    const view = editor.editing.view; // A flag whether attributes `linkHref` attribute should be preserved.\n\n    let shouldPreserveAttributes = false; // A flag whether the `Backspace` key was pressed.\n\n    let hasBackspacePressed = false; // Detect pressing `Backspace`.\n\n    this.listenTo(view.document, 'delete', (evt, data) => {\n      hasBackspacePressed = data.domEvent.keyCode === keyCodes.backspace;\n    }, {\n      priority: 'high'\n    }); // Before removing the content, check whether the selection is inside a link or at the end of link but with 2-SCM enabled.\n    // If so, we want to preserve link attributes.\n\n    this.listenTo(model, 'deleteContent', () => {\n      // Reset the state.\n      shouldPreserveAttributes = false;\n      const position = selection.getFirstPosition();\n      const linkHref = selection.getAttribute('linkHref');\n\n      if (!linkHref) {\n        return;\n      }\n\n      const linkRange = findAttributeRange(position, 'linkHref', linkHref, model); // Preserve `linkHref` attribute if the selection is in the middle of the link or\n      // the selection is at the end of the link and 2-SCM is activated.\n\n      shouldPreserveAttributes = linkRange.containsPosition(position) || linkRange.end.isEqual(position);\n    }, {\n      priority: 'high'\n    }); // After removing the content, check whether the current selection should preserve the `linkHref` attribute.\n\n    this.listenTo(model, 'deleteContent', () => {\n      // If didn't press `Backspace`.\n      if (!hasBackspacePressed) {\n        return;\n      }\n\n      hasBackspacePressed = false; // Disable the mechanism if inside a link (`<$text url=\"foo\">F[]oo</$text>` or <$text url=\"foo\">Foo[]</$text>`).\n\n      if (shouldPreserveAttributes) {\n        return;\n      } // Use `model.enqueueChange()` in order to execute the callback at the end of the changes process.\n\n\n      editor.model.enqueueChange(writer => {\n        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));\n      });\n    }, {\n      priority: 'low'\n    });\n  }\n\n} // Make the selection free of link-related model attributes.\n// All link-related model attributes start with \"link\". That includes not only \"linkHref\"\n// but also all decorator attributes (they have dynamic names), or even custom plugins.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {Array.<String>} linkAttributes\n\nfunction removeLinkAttributesFromSelection(writer, linkAttributes) {\n  writer.removeSelectionAttribute('linkHref');\n\n  for (const attribute of linkAttributes) {\n    writer.removeSelectionAttribute(attribute);\n  }\n} // Checks whether selection's attributes should be copied to the new inserted text.\n//\n// @param {module:engine/model/model~Model} model\n// @returns {Boolean}\n\n\nfunction shouldCopyAttributes(model) {\n  const selection = model.document.selection;\n  const firstPosition = selection.getFirstPosition();\n  const lastPosition = selection.getLastPosition();\n  const nodeAtFirstPosition = firstPosition.nodeAfter; // The text link node does not exist...\n\n  if (!nodeAtFirstPosition) {\n    return false;\n  } // ...or it isn't the text node...\n\n\n  if (!nodeAtFirstPosition.is('$text')) {\n    return false;\n  } // ...or isn't the link.\n\n\n  if (!nodeAtFirstPosition.hasAttribute('linkHref')) {\n    return false;\n  } // `textNode` = the position is inside the link element.\n  // `nodeBefore` = the position is at the end of the link element.\n\n\n  const nodeAtLastPosition = lastPosition.textNode || lastPosition.nodeBefore; // If both references the same node selection contains a single text node.\n\n  if (nodeAtFirstPosition === nodeAtLastPosition) {\n    return true;\n  } // If nodes are not equal, maybe the link nodes has defined additional attributes inside.\n  // First, we need to find the entire link range.\n\n\n  const linkRange = findAttributeRange(firstPosition, 'linkHref', nodeAtFirstPosition.getAttribute('linkHref'), model); // Then we can check whether selected range is inside the found link range. If so, attributes should be preserved.\n\n  return linkRange.containsRange(model.createRange(firstPosition, lastPosition), true);\n} // Checks whether provided changes were caused by typing.\n//\n// @params {module:core/editor/editor~Editor} editor\n// @returns {Boolean}\n\n\nfunction isTyping(editor) {\n  const input = editor.plugins.get('Input');\n  return input.isInput(editor.model.change(writer => writer.batch));\n} // Returns an array containing names of the attributes allowed on `$text` that describes the link item.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Array.<String>}\n\n\nfunction getLinkAttributesAllowedOnText(schema) {\n  const textAttributes = schema.getDefinition('$text').allowAttributes;\n  return textAttributes.filter(attribute => attribute.startsWith('link'));\n}","map":{"version":3,"sources":["C:/Users/sangt/OneDrive/Sang Shares Something/sss-official/client/node_modules/@ckeditor/ckeditor5-link/src/linkediting.js"],"names":["Plugin","MouseObserver","Input","TwoStepCaretMovement","inlineHighlight","findAttributeRange","ClipboardPipeline","keyCodes","LinkCommand","UnlinkCommand","ManualDecorator","createLinkElement","ensureSafeUrl","getLocalizedDecorators","normalizeDecorators","HIGHLIGHT_CLASS","DECORATOR_AUTOMATIC","DECORATOR_MANUAL","EXTERNAL_LINKS_REGEXP","LinkEditing","pluginName","requires","constructor","editor","config","define","addTargetToExternalLinks","init","model","schema","extend","allowAttributes","conversion","for","attributeToElement","view","href","conversionApi","elementToAttribute","name","attributes","key","value","viewElement","getAttribute","commands","add","linkDecorators","t","get","_enableAutomaticDecorators","filter","item","mode","_enableManualDecorators","twoStepCaretMovementPlugin","plugins","registerAttribute","_enableInsertContentSelectionAttributesFixer","_enableClickingAfterLink","_enableTypingOverLink","_handleDeleteContentAfterLink","automaticDecoratorDefinitions","command","automaticDecorators","id","callback","url","test","target","rel","length","getDispatcher","manualDecoratorDefinitions","manualDecorators","forEach","decorator","manualDecoratorName","writer","element","createAttributeElement","priority","classes","addClass","styles","setStyle","setCustomProperty","_createPattern","selection","document","listenTo","nodeBefore","anchor","nodeAfter","hasAttribute","change","removeLinkAttributesFromSelection","getLinkAttributesAllowedOnText","editing","addObserver","clicked","isCollapsed","position","getFirstPosition","linkRange","isTouching","start","end","selectionAttributes","deletedContent","isTyping","shouldCopyAttributes","getAttributes","evt","attribute","setAttribute","shouldPreserveAttributes","hasBackspacePressed","data","domEvent","keyCode","backspace","linkHref","containsPosition","isEqual","enqueueChange","linkAttributes","removeSelectionAttribute","firstPosition","lastPosition","getLastPosition","nodeAtFirstPosition","is","nodeAtLastPosition","textNode","containsRange","createRange","input","isInput","batch","textAttributes","getDefinition","startsWith"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { MouseObserver } from 'ckeditor5/src/engine';\nimport { Input, TwoStepCaretMovement, inlineHighlight, findAttributeRange } from 'ckeditor5/src/typing';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { keyCodes } from 'ckeditor5/src/utils';\n\nimport LinkCommand from './linkcommand';\nimport UnlinkCommand from './unlinkcommand';\nimport ManualDecorator from './utils/manualdecorator';\nimport { createLinkElement, ensureSafeUrl, getLocalizedDecorators, normalizeDecorators } from './utils';\n\nimport '../theme/link.css';\n\nconst HIGHLIGHT_CLASS = 'ck-link_selected';\nconst DECORATOR_AUTOMATIC = 'automatic';\nconst DECORATOR_MANUAL = 'manual';\nconst EXTERNAL_LINKS_REGEXP = /^(https?:)?\\/\\//;\n\n/**\n * The link engine feature.\n *\n * It introduces the `linkHref=\"url\"` attribute in the model which renders to the view as a `<a href=\"url\">` element\n * as well as `'link'` and `'unlink'` commands.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class LinkEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'LinkEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\t// Clipboard is required for handling cut and paste events while typing over the link.\n\t\treturn [ TwoStepCaretMovement, Input, ClipboardPipeline ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\teditor.config.define( 'link', {\n\t\t\taddTargetToExternalLinks: false\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Allow link attribute on all inline nodes.\n\t\teditor.model.schema.extend( '$text', { allowAttributes: 'linkHref' } );\n\n\t\teditor.conversion.for( 'dataDowncast' )\n\t\t\t.attributeToElement( { model: 'linkHref', view: createLinkElement } );\n\n\t\teditor.conversion.for( 'editingDowncast' )\n\t\t\t.attributeToElement( { model: 'linkHref', view: ( href, conversionApi ) => {\n\t\t\t\treturn createLinkElement( ensureSafeUrl( href ), conversionApi );\n\t\t\t} } );\n\n\t\teditor.conversion.for( 'upcast' )\n\t\t\t.elementToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'a',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\thref: true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmodel: {\n\t\t\t\t\tkey: 'linkHref',\n\t\t\t\t\tvalue: viewElement => viewElement.getAttribute( 'href' )\n\t\t\t\t}\n\t\t\t} );\n\n\t\t// Create linking commands.\n\t\teditor.commands.add( 'link', new LinkCommand( editor ) );\n\t\teditor.commands.add( 'unlink', new UnlinkCommand( editor ) );\n\n\t\tconst linkDecorators = getLocalizedDecorators( editor.t, normalizeDecorators( editor.config.get( 'link.decorators' ) ) );\n\n\t\tthis._enableAutomaticDecorators( linkDecorators.filter( item => item.mode === DECORATOR_AUTOMATIC ) );\n\t\tthis._enableManualDecorators( linkDecorators.filter( item => item.mode === DECORATOR_MANUAL ) );\n\n\t\t// Enable two-step caret movement for `linkHref` attribute.\n\t\tconst twoStepCaretMovementPlugin = editor.plugins.get( TwoStepCaretMovement );\n\t\ttwoStepCaretMovementPlugin.registerAttribute( 'linkHref' );\n\n\t\t// Setup highlight over selected link.\n\t\tinlineHighlight( editor, 'linkHref', 'a', HIGHLIGHT_CLASS );\n\n\t\t// Change the attributes of the selection in certain situations after the link was inserted into the document.\n\t\tthis._enableInsertContentSelectionAttributesFixer();\n\n\t\t// Handle a click at the beginning/end of a link element.\n\t\tthis._enableClickingAfterLink();\n\n\t\t// Handle typing over the link.\n\t\tthis._enableTypingOverLink();\n\n\t\t// Handle removing the content after the link element.\n\t\tthis._handleDeleteContentAfterLink();\n\t}\n\n\t/**\n\t * Processes an array of configured {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}\n\t * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}\n\t * for each one of them. Downcast dispatchers are obtained using the\n\t * {@link module:link/utils~AutomaticDecorators#getDispatcher} method.\n\t *\n\t * **Note**: This method also activates the automatic external link decorator if enabled with\n\t * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.\n\t *\n\t * @private\n\t * @param {Array.<module:link/link~LinkDecoratorAutomaticDefinition>} automaticDecoratorDefinitions\n\t */\n\t_enableAutomaticDecorators( automaticDecoratorDefinitions ) {\n\t\tconst editor = this.editor;\n\t\t// Store automatic decorators in the command instance as we do the same with manual decorators.\n\t\t// Thanks to that, `LinkImageEditing` plugin can re-use the same definitions.\n\t\tconst command = editor.commands.get( 'link' );\n\t\tconst automaticDecorators = command.automaticDecorators;\n\n\t\t// Adds a default decorator for external links.\n\t\tif ( editor.config.get( 'link.addTargetToExternalLinks' ) ) {\n\t\t\tautomaticDecorators.add( {\n\t\t\t\tid: 'linkIsExternal',\n\t\t\t\tmode: DECORATOR_AUTOMATIC,\n\t\t\t\tcallback: url => EXTERNAL_LINKS_REGEXP.test( url ),\n\t\t\t\tattributes: {\n\t\t\t\t\ttarget: '_blank',\n\t\t\t\t\trel: 'noopener noreferrer'\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tautomaticDecorators.add( automaticDecoratorDefinitions );\n\n\t\tif ( automaticDecorators.length ) {\n\t\t\teditor.conversion.for( 'downcast' ).add( automaticDecorators.getDispatcher() );\n\t\t}\n\t}\n\n\t/**\n\t * Processes an array of configured {@link module:link/link~LinkDecoratorManualDefinition manual decorators},\n\t * transforms them into {@link module:link/utils~ManualDecorator} instances and stores them in the\n\t * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).\n\t *\n\t * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}\n\t * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}\n\t * with adequate model attributes.\n\t *\n\t * @private\n\t * @param {Array.<module:link/link~LinkDecoratorManualDefinition>} manualDecoratorDefinitions\n\t */\n\t_enableManualDecorators( manualDecoratorDefinitions ) {\n\t\tif ( !manualDecoratorDefinitions.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst editor = this.editor;\n\t\tconst command = editor.commands.get( 'link' );\n\t\tconst manualDecorators = command.manualDecorators;\n\n\t\tmanualDecoratorDefinitions.forEach( decorator => {\n\t\t\teditor.model.schema.extend( '$text', { allowAttributes: decorator.id } );\n\n\t\t\t// Keeps reference to manual decorator to decode its name to attributes during downcast.\n\t\t\tdecorator = new ManualDecorator( decorator );\n\n\t\t\tmanualDecorators.add( decorator );\n\n\t\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t\tmodel: decorator.id,\n\t\t\t\tview: ( manualDecoratorName, { writer } ) => {\n\t\t\t\t\tif ( manualDecoratorName ) {\n\t\t\t\t\t\tconst element = writer.createAttributeElement( 'a', decorator.attributes, { priority: 5 } );\n\n\t\t\t\t\t\tif ( decorator.classes ) {\n\t\t\t\t\t\t\twriter.addClass( decorator.classes, element );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( const key in decorator.styles ) {\n\t\t\t\t\t\t\twriter.setStyle( key, decorator.styles[ key ], element );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twriter.setCustomProperty( 'link', true, element );\n\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t}\n\t\t\t\t} } );\n\n\t\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'a',\n\t\t\t\t\t...decorator._createPattern()\n\t\t\t\t},\n\t\t\t\tmodel: {\n\t\t\t\t\tkey: decorator.id\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model\n\t * selection attributes if the selection is at the end of a link after inserting the content.\n\t *\n\t * The purpose of this action is to improve the overall UX because the user is no longer \"trapped\" by the\n\t * `linkHref` attribute of the selection and they can type a \"clean\" (`linkHref`–less) text right away.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/6053.\n\t *\n\t * @private\n\t */\n\t_enableInsertContentSelectionAttributesFixer() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\tthis.listenTo( model, 'insertContent', () => {\n\t\t\tconst nodeBefore = selection.anchor.nodeBefore;\n\t\t\tconst nodeAfter = selection.anchor.nodeAfter;\n\n\t\t\t// NOTE: ↰ and ↱ represent the gravity of the selection.\n\n\t\t\t// The only truly valid case is:\n\t\t\t//\n\t\t\t//\t\t                                 ↰\n\t\t\t//\t\t...<$text linkHref=\"foo\">INSERTED[]</$text>\n\t\t\t//\n\t\t\t// If the selection is not \"trapped\" by the `linkHref` attribute after inserting, there's nothing\n\t\t\t// to fix there.\n\t\t\tif ( !selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where a link with the same href (e.g. <a href=\"foo\">INSERTED</a>) is inserted\n\t\t\t// in the middle of an existing link:\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\t\t                       ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l[]ink</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\t\t                               ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">lINSERTED[]ink</$text>\n\t\t\t//\n\t\t\tif ( !nodeBefore ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where the selection has the \"linkHref\" attribute because the\n\t\t\t// gravity is overridden and some text with another attribute (e.g. <b>INSERTED</b>) is inserted:\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\n\t\t\t//\t\t                       ↱\n\t\t\t//\t\t<$text linkHref=\"foo\">[]link</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\n\t\t\t//\t\t                                                          ↱\n\t\t\t//\t\t<$text bold=\"true\">INSERTED</$text><$text linkHref=\"foo\">[]link</$text>\n\t\t\t//\n\t\t\tif ( !nodeBefore.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Filter out the following case where a link is a inserted in the middle (or before) another link\n\t\t\t// (different URLs, so they will not merge). In this (let's say weird) case, we can leave the selection\n\t\t\t// attributes as they are because the user will end up writing in one link or another anyway.\n\t\t\t//\n\t\t\t// Before insertion:\n\t\t\t//\n\t\t\t//\t\t                       ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l[]ink</$text>\n\t\t\t//\n\t\t\t// Expected after insertion:\n\t\t\t//\n\t\t\t//\t\t                                                             ↰\n\t\t\t//\t\t<$text linkHref=\"foo\">l</$text><$text linkHref=\"bar\">INSERTED[]</$text><$text linkHref=\"foo\">ink</$text>\n\t\t\t//\n\t\t\tif ( nodeAfter && nodeAfter.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmodel.change( writer => {\n\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and\n\t * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node\n\t * if clicked at the beginning/ending of the link.\n\t *\n\t * The purpose of this action is to allow typing around the link node directly after a click.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/1016.\n\t *\n\t * @private\n\t */\n\t_enableClickingAfterLink() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\teditor.editing.view.addObserver( MouseObserver );\n\n\t\tlet clicked = false;\n\n\t\t// Detect the click.\n\t\tthis.listenTo( editor.editing.view.document, 'mousedown', () => {\n\t\t\tclicked = true;\n\t\t} );\n\n\t\t// When the selection has changed...\n\t\tthis.listenTo( editor.editing.view.document, 'selectionChange', () => {\n\t\t\tif ( !clicked ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ...and it was caused by the click...\n\t\t\tclicked = false;\n\n\t\t\tconst selection = model.document.selection;\n\n\t\t\t// ...and no text is selected...\n\t\t\tif ( !selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ...and clicked text is the link...\n\t\t\tif ( !selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst position = selection.getFirstPosition();\n\t\t\tconst linkRange = findAttributeRange( position, 'linkHref', selection.getAttribute( 'linkHref' ), model );\n\n\t\t\t// ...check whether clicked start/end boundary of the link.\n\t\t\t// If so, remove the `linkHref` attribute.\n\t\t\tif ( position.isTouching( linkRange.start ) || position.isTouching( linkRange.end ) ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}\n\t * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.\n\t *\n\t * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/4762.\n\t *\n\t * @private\n\t */\n\t_enableTypingOverLink() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\n\t\t// Selection attributes when started typing over the link.\n\t\tlet selectionAttributes;\n\n\t\t// Whether pressed `Backspace` or `Delete`. If so, attributes should not be preserved.\n\t\tlet deletedContent;\n\n\t\t// Detect pressing `Backspace` / `Delete`.\n\t\tthis.listenTo( view.document, 'delete', () => {\n\t\t\tdeletedContent = true;\n\t\t}, { priority: 'high' } );\n\n\t\t// Listening to `model#deleteContent` allows detecting whether selected content was a link.\n\t\t// If so, before removing the element, we will copy its attributes.\n\t\tthis.listenTo( editor.model, 'deleteContent', () => {\n\t\t\tconst selection = editor.model.document.selection;\n\n\t\t\t// Copy attributes only if anything is selected.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When the content was deleted, do not preserve attributes.\n\t\t\tif ( deletedContent ) {\n\t\t\t\tdeletedContent = false;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Enabled only when typing.\n\t\t\tif ( !isTyping( editor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( shouldCopyAttributes( editor.model ) ) {\n\t\t\t\tselectionAttributes = selection.getAttributes();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// Listening to `model#insertContent` allows detecting the content insertion.\n\t\t// We want to apply attributes that were removed while typing over the link.\n\t\tthis.listenTo( editor.model, 'insertContent', ( evt, [ element ] ) => {\n\t\t\tdeletedContent = false;\n\n\t\t\t// Enabled only when typing.\n\t\t\tif ( !isTyping( editor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !selectionAttributes ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\tfor ( const [ attribute, value ] of selectionAttributes ) {\n\t\t\t\t\twriter.setAttribute( attribute, value, element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tselectionAttributes = null;\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether\n\t * removing a content right after the \"linkHref\" attribute.\n\t *\n\t * If so, the selection should not preserve the `linkHref` attribute. However, if\n\t * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and\n\t * the selection has the \"linkHref\" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.\n\t *\n\t * The purpose of this action is to allow removing the link text and keep the selection outside the link.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/7521.\n\t *\n\t * @private\n\t */\n\t_handleDeleteContentAfterLink() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\t\tconst view = editor.editing.view;\n\n\t\t// A flag whether attributes `linkHref` attribute should be preserved.\n\t\tlet shouldPreserveAttributes = false;\n\n\t\t// A flag whether the `Backspace` key was pressed.\n\t\tlet hasBackspacePressed = false;\n\n\t\t// Detect pressing `Backspace`.\n\t\tthis.listenTo( view.document, 'delete', ( evt, data ) => {\n\t\t\thasBackspacePressed = data.domEvent.keyCode === keyCodes.backspace;\n\t\t}, { priority: 'high' } );\n\n\t\t// Before removing the content, check whether the selection is inside a link or at the end of link but with 2-SCM enabled.\n\t\t// If so, we want to preserve link attributes.\n\t\tthis.listenTo( model, 'deleteContent', () => {\n\t\t\t// Reset the state.\n\t\t\tshouldPreserveAttributes = false;\n\n\t\t\tconst position = selection.getFirstPosition();\n\t\t\tconst linkHref = selection.getAttribute( 'linkHref' );\n\n\t\t\tif ( !linkHref ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst linkRange = findAttributeRange( position, 'linkHref', linkHref, model );\n\n\t\t\t// Preserve `linkHref` attribute if the selection is in the middle of the link or\n\t\t\t// the selection is at the end of the link and 2-SCM is activated.\n\t\t\tshouldPreserveAttributes = linkRange.containsPosition( position ) || linkRange.end.isEqual( position );\n\t\t}, { priority: 'high' } );\n\n\t\t// After removing the content, check whether the current selection should preserve the `linkHref` attribute.\n\t\tthis.listenTo( model, 'deleteContent', () => {\n\t\t\t// If didn't press `Backspace`.\n\t\t\tif ( !hasBackspacePressed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thasBackspacePressed = false;\n\n\t\t\t// Disable the mechanism if inside a link (`<$text url=\"foo\">F[]oo</$text>` or <$text url=\"foo\">Foo[]</$text>`).\n\t\t\tif ( shouldPreserveAttributes ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use `model.enqueueChange()` in order to execute the callback at the end of the changes process.\n\t\t\teditor.model.enqueueChange( writer => {\n\t\t\t\tremoveLinkAttributesFromSelection( writer, getLinkAttributesAllowedOnText( model.schema ) );\n\t\t\t} );\n\t\t}, { priority: 'low' } );\n\t}\n}\n\n// Make the selection free of link-related model attributes.\n// All link-related model attributes start with \"link\". That includes not only \"linkHref\"\n// but also all decorator attributes (they have dynamic names), or even custom plugins.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {Array.<String>} linkAttributes\nfunction removeLinkAttributesFromSelection( writer, linkAttributes ) {\n\twriter.removeSelectionAttribute( 'linkHref' );\n\n\tfor ( const attribute of linkAttributes ) {\n\t\twriter.removeSelectionAttribute( attribute );\n\t}\n}\n\n// Checks whether selection's attributes should be copied to the new inserted text.\n//\n// @param {module:engine/model/model~Model} model\n// @returns {Boolean}\nfunction shouldCopyAttributes( model ) {\n\tconst selection = model.document.selection;\n\tconst firstPosition = selection.getFirstPosition();\n\tconst lastPosition = selection.getLastPosition();\n\tconst nodeAtFirstPosition = firstPosition.nodeAfter;\n\n\t// The text link node does not exist...\n\tif ( !nodeAtFirstPosition ) {\n\t\treturn false;\n\t}\n\n\t// ...or it isn't the text node...\n\tif ( !nodeAtFirstPosition.is( '$text' ) ) {\n\t\treturn false;\n\t}\n\n\t// ...or isn't the link.\n\tif ( !nodeAtFirstPosition.hasAttribute( 'linkHref' ) ) {\n\t\treturn false;\n\t}\n\n\t// `textNode` = the position is inside the link element.\n\t// `nodeBefore` = the position is at the end of the link element.\n\tconst nodeAtLastPosition = lastPosition.textNode || lastPosition.nodeBefore;\n\n\t// If both references the same node selection contains a single text node.\n\tif ( nodeAtFirstPosition === nodeAtLastPosition ) {\n\t\treturn true;\n\t}\n\n\t// If nodes are not equal, maybe the link nodes has defined additional attributes inside.\n\t// First, we need to find the entire link range.\n\tconst linkRange = findAttributeRange( firstPosition, 'linkHref', nodeAtFirstPosition.getAttribute( 'linkHref' ), model );\n\n\t// Then we can check whether selected range is inside the found link range. If so, attributes should be preserved.\n\treturn linkRange.containsRange( model.createRange( firstPosition, lastPosition ), true );\n}\n\n// Checks whether provided changes were caused by typing.\n//\n// @params {module:core/editor/editor~Editor} editor\n// @returns {Boolean}\nfunction isTyping( editor ) {\n\tconst input = editor.plugins.get( 'Input' );\n\n\treturn input.isInput( editor.model.change( writer => writer.batch ) );\n}\n\n// Returns an array containing names of the attributes allowed on `$text` that describes the link item.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Array.<String>}\nfunction getLinkAttributesAllowedOnText( schema ) {\n\tconst textAttributes = schema.getDefinition( '$text' ).allowAttributes;\n\n\treturn textAttributes.filter( attribute => attribute.startsWith( 'link' ) );\n}\n"]},"metadata":{},"sourceType":"module"}